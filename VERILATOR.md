# Working with Verilator

CORE-V-MCU has three `fusesoc` targets for Verilator:

1. lint
2. model-lib
3. model-lib-sim

## Verilator Lint

Run Verilator lint target for finding potential problems without generating any simulation output:

```
make lint
```

### Verilator lint check

The system will check for any new pull requests and the sanity of the lint output.
If your changes introduce any more Verilator lint warnings, you either need to fix these or, if appropriate, add a rule to ignore them to `rtl/core-v-mcu/verilator.waiver`.

## Verilator model library

To build Verilator as a library that can be linked into other tools (such as the debug server):

```
make model-lib
```

The library will be in the `obj_dir` subdirectory of the work root.

This will create the Verilator library `Vcore_v_mcu_wrapper__ALL.a` in `build/openhwgroup.org_systems_core-v-mcu_0/model-lib-verilator/obj_dir`.

Note that when you use this library to build an application you will need to
ensure that the directory `build/openhwgroup.org_systems_core-v-mcu_0/model-lib-verilator/mem_init` is either symbolically linked or copied to the directory where the application will run. The model will load ROM images from this directory.

As for the lint target, if your changes introduce any more Verilator lint warnings, you either need to fix these, or, if appropriate, add a rule to ignore them to `rtl/core-v-mcu/verilator.waiver`.

There is no testbench in this repository that uses this library.

## Verilator Simulation

To build the core-v-mcu as a Verilator library and simulate it with the 'core_v_mcu_tb.cpp' testbench follow this section.

### Prepare the system

You may need to install a few apt packages as:

```
sudo apt install libelf-dev
```

and if you want to see the waveforms generated by the simulation, install gtkwave:

```
sudo apt install libcanberra-gtk-module libcanberra-gtk3-module
sudo apt-get install -y gtkwave
```

Then, generate the header files by running in the top folder

```
make sw
```

The CORE-V-MCU BootRom expects that the system is booting either with JTAG, or with other peripherals (e.g. UART, SPI, etc).
We want to simplify this procedure and make it faster for simulation purposes, so we will preload the memories using the testbench, and we will make the core jump directly to the start address.
To do this, we need to generate a special BootRom to skip all the loading parts via peripherals.

To do so, make sure your core-v GCC compiler is in your `PATH` variable

```
export PATH=/home/yourusername/corev-gcc/bin:${PATH}
```

then,

```
cd a2_boot
make clean
make all CUSTOM_CFLAGS=-DVERILATOR BOOTCODE=verilatorBoot.mem
```

Do not commit the new ROM, as this is only meant to simplify the Verilator simulation, and it
will be supported neither by the FPGA, nor the ASIC targets.


### Verilator model library for simulation


As before, we need to build the Verilator library which creates the core-v-mcu model. Differently than before,
this model includes some testbench helper functions to pre-load memories, and the LowRISC OpenTitan [UART DPI](https://github.com/lowRISC/opentitan/tree/master/hw/dv/dpi/uartdpi).
Read how to interact with it in the Section "Interact with the simulated UART" [here](https://docs.opentitan.org/doc/ug/getting_started_verilator/).

Build it running:

```
make model-lib-sim
```

This creates the `obj_dir/Vcore_v_mcu_testharness__ALL.a` library used by the testbench,
and compiles the Verilator testbench.


### Simulating the CLI test with the Verilator Model

Launch the simulation as:

```
cd build/openhwgroup.org_systems_core-v-mcu_0/model-lib-sim-verilator
./core_v_mcu_tb.exe +dump_vcd=1 +max_sim_time=10000000
```

(dump_vcd=0 if you do not want to generate the VCD and/or omit the max_sim_time string if you want to launch the simulation without timing bounds)

The BootRom uses the `UART1` peripheral to print debug messages, if everything goes well, you will see:


```
[TESTBENCH]: No firmware  specified
[TESTBENCH]: Max Times is  10000000
[TESTBENCH]: Generating waveform.vcd
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.bank_sram_pri0_i.u0
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.bank_sram_pri1_i.u0

UART: Created /dev/pts/2 for uart0. Connect to it with any terminal program, e.g.
$ screen /dev/pts/2
UART: Additionally writing all UART output to 'uart0.log'.

UART: Created /dev/pts/3 for uart1. Connect to it with any terminal program, e.g.
$ screen /dev/pts/3
UART: Additionally writing all UART output to 'uart1.log'.
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.CUTS[0].bank_i.u0
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.CUTS[1].bank_i.u0
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.CUTS[2].bank_i.u0
TOP.core_v_mcu_testharness.core_v_mcu_i.i_soc_domain.l2_ram_i.CUTS[3].bank_i.u0
Reset Released

```

To see the UART's output, just do the:

```
cat uart1.log
```

you should see:

```
Jun  1 2022  11:18:18
A2 Bootloader Bootsel=1 rr=01
Jumping to 0x1C000880
```

If you like, you can do `$ screen /dev/pts/3` to see the UART1's output live, but be quick, otherwise, you may miss the output.

The CLI application uses the `UART0` peripheral to print the menu.

After a long-time (please be patient), you will see from the UART0 (`cat uart0.log`):

```
#*******************
Command Line Interface
Jan 13 2022 15:05:08
App SW Version: cli_test v0.2 - NoInt

#*******************
[0] >
:
```